---
layout: post
title: Error handling when enforcing invariants in the construction of statically
  checked types
date: '2018-02-18T23:24:00.001Z'
author: Robert Elliot
tags: 
modified_time: '2018-02-18T23:54:51.245Z'
blogger_id: tag:blogger.com,1999:blog-8805447266344101474.post-8205130463897428226
blogger_orig_url: http://blog.lidalia.org.uk/2018/02/error-handling-when-enforcing.html
---

tl;dr - error handling would be a lot less painful if the compiler could coerce an&nbsp;<span style="color: #20999d; font-family: &quot;menlo&quot;; font-size: 9pt;">Either</span><span style="background-color: white; font-family: &quot;menlo&quot;; font-size: 9pt;">[A, B]</span>&nbsp;to an&nbsp;<span style="background-color: white; font-family: &quot;menlo&quot;; font-size: 12px;">A</span>&nbsp;or a&nbsp;<span style="background-color: white; font-family: &quot;menlo&quot;; font-size: 12px;">B</span>&nbsp;at compile time if the program would not type check if it was an&nbsp;<span style="color: #20999d; font-family: &quot;menlo&quot;; font-size: 9pt;">Either</span><span style="background-color: white; font-family: &quot;menlo&quot;; font-size: 9pt;">[A, B]</span>, would type check if it was an&nbsp;<span style="background-color: white; font-family: &quot;menlo&quot;; font-size: 12px;">A</span>&nbsp;or a&nbsp;<span style="background-color: white; font-family: &quot;menlo&quot;; font-size: 12px;">B</span>, and whether it was in fact a&nbsp;<span style="color: #20999d; font-family: &quot;menlo&quot;; font-size: 9pt;">Left</span><span style="background-color: white; font-family: &quot;menlo&quot;; font-size: 9pt;">[A, B]</span>&nbsp;or a&nbsp;<span style="color: #20999d; font-family: &quot;menlo&quot;; font-size: 9pt;">Right</span><span style="background-color: white; font-family: &quot;menlo&quot;; font-size: 9pt;">[A, B]</span>&nbsp;was decidable at compile time.<br /><br />Here's a problem that's been bothering me for a long time - how to error handle when enforcing invariants in the construction of statically checked types. It's the nature of types to constrain the set of values they can represent. Consequently you have to construct an instance of a type from one or more other, often more general, types, and in one form or another it will frequently therefore be possible to call that constructor with values that are not in the set of valid values for that type. At which point the attempt to construct that instance of the type will hopefully be rejected, to prevent invalid program state occurring. For instance, Java has a&nbsp;<span style="background-color: white; font-family: &quot;menlo&quot;; font-size: 9pt;">URI</span>&nbsp;class with a constructor that accepts a&nbsp;<span style="background-color: white; color: #20999d; font-family: &quot;menlo&quot;; font-size: 9pt;">String</span>. Since the&nbsp;<span style="background-color: white; color: #20999d; font-family: &quot;menlo&quot;; font-size: 9pt;">String</span>&nbsp;cannot be guaranteed to be a valid&nbsp;<span style="background-color: white; font-family: &quot;menlo&quot;; font-size: 9pt;">URI</span>, the constructor throws&nbsp;<span style="background-color: white; font-family: &quot;menlo&quot;; font-size: 12px;">URISyntaxException</span>&nbsp;if it's not a valid&nbsp;<span style="background-color: white; font-family: &quot;menlo&quot;; font-size: 9pt;">URI</span>.<br /><br />This introduces a problem, and one <a href="{{ site.baseurl }}{% post_url 2010-01-29-checked-and-unchecked-exceptions %}">I've written about before</a>. Ideally in a statically type checked language the type checker will tell you about the different values a function can return. And the&nbsp;<span style="background-color: white; font-family: &quot;menlo&quot;; font-size: 9pt;">URI</span>&nbsp;constructor function does just that, via the much hated checked exception; the constructor will "return" either a valid&nbsp;<span style="background-color: white; font-family: &quot;menlo&quot;; font-size: 9pt;">URI</span>&nbsp;or the exception, and the type checker will force you to do something about it.<br /><br />In more functional languages such as Scala or Haskell we might represent that via a genuine return type - an&nbsp;<span style="color: #20999d; font-family: &quot;menlo&quot;; font-size: 9pt;">Either</span><span style="background-color: white; font-family: &quot;menlo&quot;; font-size: 9pt;">[URISyntaxException, URI]</span>, or a&nbsp;<span style="background-color: white; font-family: &quot;menlo&quot;; font-size: 9pt;">Try[URI]</span>,&nbsp;or perhaps&nbsp;<span style="background-color: white; font-family: &quot;menlo&quot;; font-size: 9pt;">Option[URI]&nbsp;</span>if we're not interested in giving much feedback on what went wrong. Which is all fine and dandy if the input is untrusted. I like the type checker to remind me that if I take some input from a user and try and turn it into a URI I need to handle the case when the user has failed to oblige.<br /><br />However, it becomes a lot more irritating in the case where we <b>know</b>&nbsp;the input is valid. Whether it's because we're using the language to configure something, or writing a test, or just jamming a little bit of code together to do something right now&nbsp;that doesn't need to take inputs and validate them, there are times when you just want to hardcode that value and so there's no error handling to be done.<br /><br />Let's say we define a type to represent the set of natural numbers:<br /><br /><pre style="background-color: white; font-family: Menlo; font-size: 9pt;"><span style="color: navy; font-weight: bold;">object </span>Natural {<br /><br />  <span style="color: navy; font-weight: bold;">def </span>apply(natural: Int): <span style="color: #20999d;">Either</span>[<span style="color: #20999d;">IllegalArgumentException</span>, Natural] =<br />    <span style="color: navy; font-weight: bold;">if </span>(natural &gt; <span style="color: blue;">0</span>) <span style="color: #660e7a; font-style: italic;">Right</span>(<span style="color: navy; font-weight: bold;">new </span>Natural(natural))<br />    <span style="color: navy; font-weight: bold;">else </span><span style="color: #660e7a; font-style: italic;">Left</span>(<span style="color: navy; font-weight: bold;">new </span>IllegalArgumentException(<span style="color: green; font-weight: bold;">s"</span><span style="color: #00b8bb; font-weight: bold;">$</span>natural<span style="color: green; font-weight: bold;"> is not a Natural number"</span>))<br />}<br /><br /><span style="color: navy; font-weight: bold;">case class </span>Natural <span style="color: navy; font-weight: bold;">private </span>(natural: Int) <span style="color: navy; font-weight: bold;">extends</span> AnyVal</pre><br />Cool - there's only one way to construct it, which enforces the invariant we want, and the type checker tells us it may not succeed. And let's define a function that will use it:<br /><br /><pre style="background-color: white; font-family: Menlo; font-size: 9pt;"><span style="color: navy; font-weight: bold;">def </span>sumOfFirst(n: Natural): Natural = ???</pre><br />OK, let's test it:<br /><br /><pre style="background-color: white; font-family: Menlo; font-size: 9pt;"><span style="font-style: italic;">test</span>(<span style="color: green; font-weight: bold;">"sum of first 4 natural numbers"</span>) {<br />  sumOfFirst(<span style="font-style: italic;">Natural</span>(<span style="color: blue;">4</span>)) mustBe <span style="font-size: 9pt; font-style: italic;">Natural</span><span style="font-size: 9pt;">(</span><span style="color: blue; font-size: 9pt;">10</span><span style="font-size: 9pt;">)</span><br />}</pre><br />And... compiler says no. I'm trying to pass an&nbsp;<span style="color: #20999d; font-family: &quot;menlo&quot;; font-size: 9pt;">Either</span><span style="background-color: white; font-family: &quot;menlo&quot;; font-size: 9pt;">[</span><span style="color: #20999d; font-family: &quot;menlo&quot;; font-size: 9pt;">IllegalArgumentException</span><span style="background-color: white; font-family: &quot;menlo&quot;; font-size: 9pt;">, Natural]&nbsp;</span>to a function that expects a plain&nbsp;<span style="background-color: white; font-family: &quot;menlo&quot;; font-size: 9pt;">Natural</span>, and I'm trying to compare the resulting plain&nbsp;<span style="background-color: white; font-family: &quot;menlo&quot;; font-size: 9pt;">Natural</span>&nbsp;with an&nbsp;<span style="color: #20999d; font-family: &quot;menlo&quot;; font-size: 9pt;">Either</span><span style="background-color: white; font-family: &quot;menlo&quot;; font-size: 9pt;">[</span><span style="color: #20999d; font-family: &quot;menlo&quot;; font-size: 9pt;">IllegalArgumentException</span><span style="background-color: white; font-family: &quot;menlo&quot;; font-size: 9pt;">, Natural]</span>. Not going to work. But making the compiler happy is going to make a bit of a mess of what was a fairly legible test:<br /><pre style="background-color: white; font-family: Menlo; font-size: 9pt;"><span style="font-style: italic;"><br /></span></pre><pre style="background-color: white; font-family: Menlo; font-size: 9pt;"><span style="font-style: italic;">test</span>(<span style="color: green; font-weight: bold;">"sum of first 4 natural numbers"</span>) {<br />  <span style="font-style: italic;">Natural</span>(<span style="color: blue;">4</span>).map(<span style="font-style: italic;">sumOfFirst</span>) mustBe <span style="font-style: italic;">Natural</span>(<span style="color: blue;">10</span>)<br />}</pre><br />So now you've got the additional cognitive load of mapping over an&nbsp;<span style="color: #20999d; font-family: &quot;menlo&quot;; font-size: 12px;">Either</span>&nbsp;to call the function you wanted to test, plus the fact that the types you are actually comparing in the assertion are both&nbsp;<span style="color: #20999d; font-family: &quot;menlo&quot;; font-size: 9pt;">Either</span><span style="background-color: white; font-family: &quot;menlo&quot;; font-size: 9pt;">[</span><span style="color: #20999d; font-family: &quot;menlo&quot;; font-size: 9pt;">IllegalArgumentException</span><span style="background-color: white; font-family: &quot;menlo&quot;; font-size: 9pt;">, Natural]</span>&nbsp;rather than the simple&nbsp;<span style="background-color: white; font-family: &quot;menlo&quot;; font-size: 12px;">Natural</span>&nbsp;you were interested in. Not nice.<br /><br />In the URI case mentioned earlier, Java provides a get out of jail option -&nbsp;<span style="color: navy; font-family: &quot;menlo&quot;; font-size: 9pt; font-weight: bold;">public static </span><span style="background-color: white; font-family: &quot;menlo&quot;; font-size: 9pt;">URI create(String str)</span>&nbsp; does not throw a checked exception, it will only fail at runtime if the string is invalid. And we could do likewise for Natural. But that's a bit unsatisfying, because in the process we've opened up the possibility that the programmer abuses that facility, and the type checker has thereby lost some of its ability to prove our programs correct.<br /><br />Scala offers some interesting string parsing options where the compiler can start statically checking the contents of a String to create an instance of a constrained type and report any failure at compile time; Jon Pretty has made this significantly easier with <span style="color: #0000ee;"><u><a href="http://co.ntextu.al/">http://co.ntextu.al/</a>.</u></span><br /><br />However, it occurs to me that there might be a more general way of doing this. What if, in cases where a pure function returns a result of type&nbsp;<span style="color: #20999d; font-family: &quot;menlo&quot;; font-size: 9pt;">Either</span><span style="background-color: white; font-family: &quot;menlo&quot;; font-size: 9pt;">[A, B]</span>, but is being used in a way that means the compiler expects its result to be a plain A or a plain B,&nbsp;and it is called in such a way that its arguments are fully known at compile time,&nbsp;the compiler could actually call the function at compile time and check whether it returns a&nbsp;<span style="color: #660e7a; font-family: &quot;menlo&quot;; font-size: 9pt; font-style: italic;">Left</span><span style="background-color: white; font-family: &quot;menlo&quot;; font-size: 9pt;">(a: A)</span>&nbsp;or a&nbsp;<span style="color: #660e7a; font-family: &quot;menlo&quot;; font-size: 9pt; font-style: italic;">Right</span><span style="background-color: white; font-family: &quot;menlo&quot;; font-size: 9pt;">(b: </span><span style="color: #20999d; font-family: &quot;menlo&quot;; font-size: 9pt;">B</span><span style="background-color: white; font-family: &quot;menlo&quot;; font-size: 9pt;">)</span>? And if it returns the correct one, permit its use directly as an A or B? And if not, report the other as the text of a compile error?<br /><br />This would then work entirely seamlessly, with no library code, and would not require any String parsing for cases such as our&nbsp;<span style="background-color: white; font-family: &quot;menlo&quot;; font-size: 12px;">Natural</span>&nbsp;above that are not naturally stringy, so long as your constructor function enforces its invariants and reports the result as an&nbsp;<span style="background-color: white; color: #20999d; font-family: &quot;menlo&quot;; font-size: 12px;">Either</span>. The first version of the test case above would happily pass, as both the constructions of&nbsp;<span style="background-color: white; font-family: &quot;menlo&quot;; font-size: 12px;">Natural</span>&nbsp;could be proved at compile time to return a&nbsp;<span style="color: #660e7a; font-family: &quot;menlo&quot;; font-size: 9pt; font-style: italic;">Right</span><span style="background-color: white; font-family: &quot;menlo&quot;; font-size: 9pt;">(n:&nbsp;</span><span style="background-color: white; font-family: &quot;menlo&quot;; font-size: 9pt; font-style: italic;">Natural</span><span style="background-color: white; font-family: &quot;menlo&quot;; font-size: 9pt;">)</span>&nbsp;and hence be coerced to a&nbsp;<span style="background-color: white; font-family: &quot;menlo&quot;; font-size: 12px;">Natural</span>&nbsp;since that would type check and the&nbsp;<span style="color: #20999d; font-family: &quot;menlo&quot;; font-size: 9pt;">Either</span><span style="background-color: white; font-family: &quot;menlo&quot;; font-size: 9pt;">[</span><span style="color: #20999d; font-family: &quot;menlo&quot;; font-size: 9pt;">IllegalArgumentException</span><span style="background-color: white; font-family: &quot;menlo&quot;; font-size: 9pt;">, Natural]&nbsp;</span>type would not.<br /><br />The compiler would of course be clever enough to still treat the output as an&nbsp;<span style="color: #20999d; font-family: &quot;menlo&quot;; font-size: 9pt;">Either</span><span style="background-color: white; font-family: &quot;menlo&quot;; font-size: 9pt;">[A, B]</span>&nbsp;if it were being used in a context that required it to be an&nbsp;<span style="color: #20999d; font-family: &quot;menlo&quot;; font-size: 9pt;">Either</span><span style="background-color: white; font-family: &quot;menlo&quot;; font-size: 9pt;">[A, B]</span>&nbsp;- indeed, that would be the default. Only if the required type of the output was not satisfied by the type&nbsp;<span style="color: #20999d; font-family: &quot;menlo&quot;; font-size: 9pt;">Either</span><span style="background-color: white; font-family: &quot;menlo&quot;; font-size: 9pt;">[A, B]</span>&nbsp;but <i>was</i>&nbsp;satisfied by either the type&nbsp;<span style="background-color: white; font-family: &quot;menlo&quot;; font-size: 12px;">A</span>&nbsp;or the type&nbsp;<span style="background-color: white; font-family: &quot;menlo&quot;; font-size: 12px;">B</span>&nbsp;would it bother to start trying to work out whether it was decidable at compile time, and if so which it was.<br /><br />