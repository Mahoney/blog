---
layout: post
title: Injecting a bean into a Grails Controller without using auto-wiring
date: '2010-06-13T15:37:00.004+01:00'
author: Robert Elliot
tags: 
modified_time: '2010-09-20T16:17:39.696+01:00'
blogger_id: tag:blogger.com,1999:blog-8805447266344101474.post-1840037548847826379
blogger_orig_url: http://blog.lidalia.org.uk/2010/06/injecting-bean-into-grails-controller.html
---

<p>Imagine a nice simple Grails app - Foo1Controller and Foo2Controller both have a BarService property, auto injected by name as Grails likes to do.</p><pre class="brush:groovy"><br />package foo <br />class Foo1Controller { <br />  BarService barService <br /><br />  def anAction = {<br />    barService.doSomething() <br />  }<br /> }<br /><br />package foo<br />class Foo2Controller { <br />  BarService barService<br /><br />   def anotherAction = {<br />     barService.doSomething()<br />   } <br />}<br /><br />BarService {<br />   void doSomeThing() {<br />     // do something <br />  }<br /> } <br /></pre><p>All is well, until we find that actually we need two different implementations of BarService, and the two controllers must each use a different one.</p><p>The initial refactor of the service is simple:</p><pre class="brush:groovy"><br />interface BarService {<br />  void doSomething()<br /> }<br /><br />   class Bar1Service implements BarService { <br />  void doSomeThing() { <br />    // do something<br />  }<br />}<br /><br />class Bar2Service implements BarService {<br />  void doSomeThing() {<br />    // do something else<br />  }<br />}<br /></pre><p>Grails uses Spring, right?  So we can just choose to inject the right one into the right controller!  Problem is that Grails likes to auto-wire its controllers by name (or by type if you prefer).  Not so hot for a configuration &amp; server restart based change in implementation.  You're going to have to alter the source code to persuade Grails to wire Bar1Service into Foo1Controller and Bar2Service into Foo2Controller.</p><p>Well, turns out you can just do it in resources.groovy as so:</p><pre class="brush:groovy"><br />barService(Bar1Service) { bean -&gt;<br />  bean.autowire = 'byName'<br />}<br /><br />'foo.Foo2Controller'(Foo2Controller) { bean -&gt;<br />  bean.scope = 'prototype'<br />  bean.autowire = 'byName'<br />  barService = ref(ConfigurationHolder.config.foo2.barservice)<br />}<br /></pre><p>Config.groovy:</p><pre class="brush:groovy"><br />foo2.barservice = 'bar2Service' // valid values are barService and bar2Service<br /></pre><p>Now, so long as your config is loaded from outside the war file, you can switch the implementation of BarService for Foo2Controller in config, restart and all is good - no need for a redeploy.</p><p>Interesting points:<br /><ul><li>By declaring Bar1Service with a name of barService in resources.groovy, we still got all the benefits of it being auto-wired into any controller (such as Foo1Controller) that declares a barService without needing to declare that controller in resources.groovy</li><li>By using bean.autowire = 'byName' in all the bean declarations we got the default Grails wiring for all other properties</li><li>When declaring the Controller in order to choose the BarService implementation we needed the full name - package.ClassName - as the bean name</li><li>When declaring the Controller we needed to give it a scope of prototype - to ensure we get a new instance of the Controller each time</li></ul></p><p>One other thing - we're stuck on Grails 1.1.1.  So no guarantees this works with the latest version - though we are about to upgrade, so hopefully I'll be able to edit this post and remove this caveat soon.</p>