---
layout: post
title: REST and the Problem of Updating Resources as Representations Change
date: '2011-12-16T11:45:00.001Z'
author: Robert Elliot
tags: 
modified_time: '2011-12-16T14:34:36.463Z'
blogger_id: tag:blogger.com,1999:blog-8805447266344101474.post-8932297441624166309
---

<p>The project I currently work on is a REST API that exposes quite a complex resource to multiple internal clients, and we've been wrestling with the problem of how to allow multiple clients to modify an existing instance this resource.  We expose the resource as JSON. </p><p>The simplest case is to allow them to PUT the entire resource.  This is slightly dangerous; because the body of a PUT represents the entire state of the resource, there is scope here for the client accidentally to delete data.  Typically a client will unmarshall the JSON into a domain object of some form.  If they do so in a static, strongly typed language like Java using one of the typical reflection based mechanisms available like Jackson there is a possibility that they will in the process silently discard attributes of the JSON that do not map to properties on their domain class.  The client then modifies their domain instance and marshalls it to JSON that does not contain the discarded data; when they then PUT that representation back to the service the service should honour the contract of PUT and treat that new representation as the entire state of the resource, and so delete those attributes.</p><p>This is obviously undesirable.  It is, however, not a big deal for the API in its initial state; so long as the clients understand that they need to maintain all the data they can reasonable be expected to bind properly to a documented media type so that their static internal domain classes reliably maintain all the data.  And testing should rapidly reveal the problem if they don't.</p><p>The problem comes as the API needs to evolve whilst having existing clients.  Typically we find we need a new attribute on the resource.  This requirement will normally be driven by one of our clients - and not be of interest to the others.  If we simply add that attribute to the media type then the chances of accidental data loss increase significantly; the client that needed the new attribute will start adding that data as it updates the resource, but other clients that do not know about it will remove it when they update the same resource.</p><p>We came up with the following potential strategies to handle this: <ol><li>Version the media type when adding an attribute</li><li>Break the resource up into several resources</li><li>Break the resource up into several resources and version the media type when adding an attribute</li><li>Allow partial updates via PUT: http://bitworking.org/news/296/How-To-Do-RESTful-Partial-Updates</li><li>Allow partial updates via POST</li></ol></p>